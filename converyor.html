<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Conveyor</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0">
		<style>
			body {
				color: #000000;
				font-family:Monospace;
				font-size:15px;
				text-align:center;

				background-color: #f0f0f0;
				margin: 0px;
			}

			#container{
				position: relative;
				line-height: 80%;
			}

			#recipeSelector{
				position: absolute;
				width: 250px;
				height: 300px;
				left: 50%;
				top: 50%;
				margin-left: -125px;
				margin-top: -150px;
				padding: 2px;
				border: 2px solid #000000;
				background-color: #ffffaf;
				text-align: left;
			}

			div.closeButton{
				position: absolute;
				width: 16px;
				height: 16px;
				right: 2px;
				top: 2px;
				border: 1px solid #7f7f7f;
				background-image: url("img/close.png");
			}

			.recipe-box{
				border: 1px solid #0000ff; margin: 4px; background-color: #afafff;
			}

			.overlay{
				position: absolute;
				left: 0px;
				top: 0px;
				width: 100%;
				height: 100%;
				color: rgb(0,0,0);
				font-weight: bold;
				text-shadow: 1px 1px #fff, -1px -1px 0 #fff, 1px -1px 0 #fff, -1px 1px 0 #fff;
				text-align: right;
			}

			#points{
				font-size: 25px;
			}

			/* Class that prevents text selection by mouse dragging.
			  The style is not defined by standard, so we'd write down browser-dependent styles for major browsers.
			  Support by IE11 is somewhat incomplete since Ctrl+A selects the text in elements even with this style. */
			.noselect{
				-webkit-touch-callout: none; /* iOS Safari */
				-webkit-user-select: none;   /* Chrome/Safari/Opera */
				-khtml-user-select: none;    /* Konqueror */
				-moz-user-select: none;      /* Firefox */
				-ms-user-select: none;       /* IE/Edge */
				user-select: none;           /* non-prefixed version, currently
											  not supported by any browser */
			}

		</style>
	</head>
	<body>
		<h1>Conveyor</h1>
		Size:
		<select id="sizeSelect">
			<option>16</option>
			<option selected>24</option>
			<option>32</option>
			<option>48</option>
			<option>64</option>
			<option>128</option>
			<option>256</option>
		</select>
		<input type="button" onclick="generateBoard()" value="Start">
		<hr>
		<div style="position: relative">
			<div id="container"></div>
			<div id="recipeSelector">
				<div id="recipeSelectorContent"></div>
				<div class="closeButton" onclick="hideRecipeSelect()"></div>
			</div>
		</div>
		<div id="points"></div>
		<hr>
		<div id="highScores"></div>
		<hr>

		<script>
		var container;
		var table;
		var size;
		var viewPortWidth;
		var viewPortHeight;
		var board;
		var tileElems;
		var scrollPos = [0, 0];
		var selectedTile = null;
		var selectedCoords = null;
		var cursorElem;
		var messageElem;
		var debugText;
		var infoElem;
		var playerElem;
		var miniMapSize = 150;
		var miniMapElem;
		var miniMapCursorElem;
		var recipeTarget = null;

		// Constants
		var tilesize = 32;
		var objsize = tilesize / 3;
		var objViewSize = tilesize / 2; // View size is slightly greater than hit detection radius

		var toolBarElem;
		var toolElems = [];
		var toolCursorElem;

		// Placeholder object for player
		var player = {inventory: {}, selectedInventory: null};

/// Mix fields of source into target.
/// This can be used like a dirty multiple inheritance.
function mixin(target, source){
	for(var k in source){
		target[k] = source[k];
	}
}

/// Custom inheritance function that prevents the super class's constructor
/// from being called on inehritance.
/// Also assigns constructor property of the subclass properly.
/// @param subclass The constructor of subclass that should be inherit base
/// @param base The constructor of the base class which subclass's prototype should point to.
/// @param methods Optional argument for a table containing methods to define for subclass.
///                The table is mixed-in to subclass, so it won't be a base class of subclass.
function inherit(subclass,base,methods){
	// If the browser or ECMAScript supports Object.create, use it
	// (but don't remember to redirect constructor pointer to subclass)
	if(Object.create){
		subclass.prototype = Object.create(base.prototype);
	}
	else{
		var sub = function(){};
		sub.prototype = base.prototype;
		subclass.prototype = new sub;
	}
	if(methods)
		mixin(subclass.prototype, methods);
	subclass.prototype.constructor = subclass;
}

		function Structure(){
			this.tile = null;
		}

		Structure.prototype.draw = function(tileElem){
			if(this.symbol instanceof Array){
				tileElem.innerHTML = this.symbol[this.rotation];
			}
			else{
				tileElem.innerHTML = this.symbol;
			}
		};

		/// Function to respond when an object is on it.
		/// Do nothing by default.
		Structure.prototype.objectResponse = function(tile, o){};

		/// Function that is called for every tile every simulation step.
		Structure.prototype.frameProc = function(){};

		/// Returns whether this structure can convey items on it.
		/// Default is false.
		Structure.prototype.movable = function(){
			return false;
		};

		// Default is unable to input or output items.
		Structure.prototype.input = function(){return false};
		Structure.prototype.output = function(){return false};

		// Transport belt
		function TransportBelt(){}
		inherit(TransportBelt, Structure, {
			name: "Transport Belt",
			symbol: ["&lt;", "^", "&gt;", "V"],

			draw: function(tileElem){
				var imgElem = document.createElement('div');
				imgElem.style.position = 'absolute';
				imgElem.style.left = '0px';
				imgElem.style.top = '0px';
				imgElem.style.width = tilesize + 'px';
				imgElem.style.height = tilesize + 'px';
				imgElem.style.backgroundImage = 'url("img/transport.png")';
				imgElem.style.backgroundPosition = (simstep) % 32 + 'px 0';
				imgElem.style.transform = 'rotate(' + (this.rotation * 90 + 180) + 'deg)';
				imgElem.style.borderStyle = 'none';
				tileElem.appendChild(imgElem);
				this.imgElem = imgElem;
			},

			objectResponse: function(tile, o){
				var vx = [-1, 0, 1, 0][this.rotation];
				var vy = [0, -1, 0, 1][this.rotation];
				var newx = Math.min(size * tilesize, Math.max(0, o.x + vx));
				var newy = Math.min(size * tilesize, Math.max(0, o.y + vy));
				if(!movableTile(newx, newy) || hitCheck(newx, newy, o))
					return;
				o.x = newx;
				o.y = newy;
				positionObject(o);
			},

			frameProc: function(){
				var imgElem = this.imgElem;
				imgElem.style.backgroundPosition = simstep % 32 + 'px 0';
			},

			movable: function(tile){
				return true;
			},
		});

		// Inserter
		function Inserter(){
			this.cooldown = 0;
		}
		inherit(Inserter, Structure, {
			name: "Inserter",
			symbol: ["&lt;<br>I", "^<br>I", "&gt;<br>I", "V<br>I"],

			draw: function(tileElem){
				var baseElem = document.createElement('img');
				baseElem.src = 'img/inserter-base.png';
				baseElem.style.left = '0px';
				baseElem.style.top = '0px';
				baseElem.style.position = 'absolute';
				tileElem.appendChild(baseElem);
				var directionElem = document.createElement('img');
				directionElem.src = 'img/direction.png';
				directionElem.style.transform = 'rotate(' + (this.rotation * 90) + 'deg)';
				directionElem.style.position = 'relative';
				tileElem.appendChild(directionElem);
			},

			frameProc: function(){
				if(this.cooldown < 1)
					this.cooldown = 0;
				else
					this.cooldown--;

				if(0 < this.cooldown)
					return;
				var idx = board.indexOf(this.tile);
				var tx = idx % size;
				var ty = Math.floor(idx / size);

				var vx = [-1, 0, 1, 0][this.rotation];
				var vy = [0, -1, 0, 1][this.rotation];
				var sx = tx - vx;
				var sy = ty - vy;
				var sourceTile = board[sx + sy * size];
				var dx = tx + vx;
				var dy = ty + vy;
				var destTile = board[dx + dy * size];

				// If the source is a producer and destination is a transport belt, put a product into the belt.
				if(sourceTile.structure && sourceTile.structure.output){
//						if(sourceTile.structure.output.call(sourceTile, dx, dy)){
					if(sourceTile.structure.output(dx, dy)){
						this.cooldown = 10;
						return;
					}
				}

				// If the destinatoin is a destroyer, put the object into the destroyer and cosume it.
				findItem(sx, sy, function(o){
					return destTile.structure && destTile.structure.input(o);
				}, true);
			}
		});

		/// Abstract class for structures that can contain items
		function Container(){
			Structure.call(this);
			this.inventory = {};
		}
		inherit(Container, Structure);

		/// Print contents of inventory
		Container.prototype.desc = function(tile){
			var ret = "Items:<br>";
			for(var i in this.inventory)
				ret += "  " + i + ": " + this.inventory[i] + "<br>";
			return ret;
		};

		Container.prototype.input = function(o){
			this.addItem(o);
			return true;
		};

		Container.prototype.output = function(dx, dy){
			var firstItem = null;
			for(var i in this.inventory)
				firstItem = i;
			if(!firstItem)
				return false;
			if(newObject(dx, dy, firstItem)){
				if(--this.inventory[firstItem] === 0)
					delete this.inventory[firstItem];
				return true;
			}
			return false;
		};

		Container.prototype.addItem = function(item){
			if(!(item.type in this.inventory))
				this.inventory[item.type] = item.amount || 1;
			else
				this.inventory[item.type] += item.amount || 1;
		};

		function Chest(){
			Container.call(this);
		}
		inherit(Chest, Container, {
			name: "Chest",
			symbol: 'C',

			draw: function(tileElem){
				var imgElem = document.createElement('img');
				imgElem.src = 'img/chest.png';
				imgElem.style.left = '0px';
				imgElem.style.top = '0px';
				imgElem.style.position = 'absolute';
				tileElem.appendChild(imgElem);
			},
		});

		// Ore Mine
		function OreMine(){
			Structure.call(this);
			this.cooldown = 0;
			this.recipe = null;
		}
		inherit(OreMine, Structure, {
			name: "Ore Mine",
			symbol: ["&lt;<br>Mi", "^<br>Mi", "&gt;<br>Mi", "V<br>Mi"],

			draw: function(tileElem){
				var imgElem = document.createElement('img');
				imgElem.src = 'img/mine.png';
				imgElem.style.left = '0px';
				imgElem.style.top = '0px';
				imgElem.style.position = 'absolute';
				tileElem.appendChild(imgElem);
				var directionElem = document.createElement('img');
				directionElem.src = 'img/direction.png';
				directionElem.style.transform = 'rotate(' + (this.rotation * 90) + 'deg)';
				directionElem.style.position = 'relative';
				tileElem.appendChild(directionElem);
			},

			desc: function(tile){
				var ret = ""
				// Progress bar
				if(this.recipe)
					ret += "<div style='position: relative; width: 100px; height: 10px; background-color: #001f1f; margin: 2px; border: 1px solid #3f3f3f'>" +
						"<div style='position: absolute; width: " + (this.recipe.time - this.cooldown) / this.recipe.time * 100 + "px; height: 10px; background-color: #ff00ff'></div></div>" +
						"Expected output: " + tile.ironOre + "<br>";
				ret += "Outputs: Ore<br>" +
					"Time: 50<br>";
				return ret;
			},

			frameProc: function(){
				if(this.recipe === null){
					if(0 < this.tile.ironOre){
						this.recipe = {time: 80};
						this.cooldown = this.recipe.time;
					}
				}
				if(this.cooldown < 1)
					this.cooldown = 0;
				else
					this.cooldown--;

				var idx = board.indexOf(this.tile);
				var tx = idx % size;
				var ty = Math.floor(idx / size);
				var vx = [-1, 0, 1, 0][this.rotation];
				var vy = [0, -1, 0, 1][this.rotation];
				var dx = tx + vx;
				var dy = ty + vy;
				var destTile = board[dx + dy * size];

				// Ore mine can output minerals without inserters
				this.output(dx, dy);
			},
			output: function(dx, dy){
				if(0 < this.cooldown)
					return false;
				if(this.tile.ironOre <= 0)
					return false; // Exhausted
				if(newObject(dx, dy, 'O')){
					this.cooldown = this.recipe.time;
					this.tile.ironOre--;
					return true;
				}
				else
					return false;
			}
		});

		// The base class for all factory classes, which produces something
		// out from ingredients
		function Factory(){
			Container.call(this);
			this.cooldown = 0;
			this.consumeCooldown = 0;
			this.recipe = null;
			this.processing = false;
		}
		inherit(Factory, Container, {
			desc: function(tile){
				if(!this.recipe)
					return "No recipe";

				// Progress bar
				var ret = "<div style='position: relative; width: 100px; height: 10px; background-color: #001f1f; margin: 2px; border: 1px solid #3f3f3f'>"
					+ "<div style='position: absolute; width: " + (this.recipe.time - this.cooldown) / this.recipe.time * 100 + "px; height: 10px; background-color: #00ffff'></div></div>";

				ret += "Recipe: " + recipeDraw(this.recipe);
				return ret + Container.prototype.desc.call(this);
			},

			frameProc: function(tile){
				if(this.recipe){
					if(this.processing){
						if(this.cooldown < 1){
							this.processing = false;
							this.cooldown = 0;
							for(var k in this.recipe.output){
								this.inventory[k] = (this.inventory[k] || 0) + this.recipe.output[k];
							}
						}
						else
							this.cooldown--;
					}
					else{
						var good = true;
						for(var k in this.recipe.input){
							if(this.inventory[k] && this.recipe.input[k] <= this.inventory[k])
								;
							else{
								good = false;
								break;
							}
						}

						if(good){
							for(var k in this.recipe.input){
								this.inventory[k] -= this.recipe.input[k];
								if(this.inventory[k] === 0)
									delete this.inventory[k];
							}
							this.processing = true;
							this.cooldown = this.recipe.time;
						}
						return true;
					}
				}
			},

			input: function(o){
				if(!this.recipe)
					return false;
				if(!(o.type in this.recipe.input))
					return false;
				if(0 < this.cooldown)
					return false;
				this.addItem(o);

				return true;
			},

			output: function(dx, dy){
				for(var k in this.inventory){
					if(this.recipe && this.recipe.input[k])
						continue;
					if(newObject(dx, dy, k)){
						if(--this.inventory[k] === 0)
							delete this.inventory[k];
						return true;
					}
				}
				return false;
			}
		});

		// Furnace
		function Furnace(){
			Factory.call(this);
			this.recipe = {
				input: {'O': 1},
				output: {'M': 1},
				time: 20,
			};
		}
		inherit(Furnace, Factory, {
			name: "Furnace",
			symbol: 'F',

			draw: function(tileElem){
				var imgElem = document.createElement('img');
				imgElem.src = 'img/furnace.png';
				imgElem.style.left = '0px';
				imgElem.style.top = '0px';
				imgElem.style.position = 'absolute';
				tileElem.appendChild(imgElem);
			},
		});

		// Assembler
		function Assembler(){
			Factory.call(this);
		}
		inherit(Assembler, Factory, {
			name: "Assembler",
			symbol: 'A',

			draw: function(tileElem){
				var imgElem = document.createElement('img');
				imgElem.src = 'img/assembler.png';
				imgElem.style.left = '0px';
				imgElem.style.top = '0px';
				imgElem.style.position = 'absolute';
				tileElem.appendChild(imgElem);
			},

			recipes: function(){
				return [
					{
						input: {'M': 1},
						output: {'Gear': 1},
						time: 20,
					},
					{
						input: {'M': 1, 'Gear': 1},
						output: {'Transport Belt': 1},
						time: 20,
					},
					{
						input: {'M': 5},
						output: {'Chest': 1},
						time: 60,
					},
					{
						input: {'M': 5, 'Gear': 3},
						output: {'Inserter': 1},
						time: 100,
					},
					{
						input: {'M': 5, 'Gear': 10},
						output: {'Ore Mine': 1},
						time: 100,
					}
				]
			},
		});

		var toolDefs = [
			TransportBelt,
			Inserter,
			Chest,
			OreMine,
			Furnace,
			Assembler,
		];

		var currentTool = -1;
		var currentRotation = 0;

		var objects = [];

		function iterateTiles(func){
			for(var iy = 0; iy < size; iy++){
				for(var ix = 0; ix < size; ix++){
					func(ix, iy);
				}
			}
		}

		function rotate(){
			if(0 <= currentTool){
				currentRotation = (currentRotation + 1) % 4;
				toolDefs[currentTool].prototype.rotation = currentRotation;
				updateTool(currentTool);
			}
			else if(selectedCoords !== null){
				var tile = board[selectedCoords[0] + selectedCoords[1] * size];
				tile.rotation = (tile.rotation + 1) % 4;
				updateTile(tile);
			}
		}

		/// Searches through all dropped items matching position sx and sy in
		/// the world and check with proc functon passed by the caller.
		/// if proc returns nonzero, the item is considered consumed and
		/// disappear from the ground.
		function findItem(sx, sy, proc, single){
			for(var j = 0; j < objects.length;){
				var o = objects[j];
				var otx = Math.floor(o.x / tilesize);
				var oty = Math.floor(o.y / tilesize);
				if(otx === sx && oty === sy && proc(o)){
					table.removeChild(o.elem);
					objects.splice(j, 1);
					this.cooldown = 10;
					if(single)
						return;
				}
				else{
					// If we happend to successfully find the object and remove
					// it from object list, incrementing j would skip one extra item.
					j++;
				}
			}
		}

		function recipeDraw(recipe, onclick){
			var ret = "";
			ret += "<div class='recipe-box'"
				+ (onclick ? " onclick='" + onclick + "'" : "") + ">";
			ret += "<span style='display: inline-block; margin: 1px'>" +
				getHTML(generateItemImage("time", true, recipe.time), true) + "</span>";
			ret += "<span style='display: inline-block; width: 30%'>";
			for(var k in recipe.input)
				ret += getHTML(generateItemImage(k, true, recipe.input[k]), true);
			ret += "</span><img src='img/rightarrow.png' style='width: 20px; height: 32px'><span style='display: inline-block; width: 30%'>";
			for(var k in recipe.output)
				ret += getHTML(generateItemImage(k, true, recipe.output[k]), true);
			ret += "</span></div>";
			return ret;
		}

		/// Convert a HTML element to string.
		/// If deep === true, descendants are serialized, too.
		function getHTML(who, deep){
			var div = document.createElement('div');
			div.appendChild(who.cloneNode(false));
			var txt = div.innerHTML;
			if(deep){
				var ax = txt.indexOf('>')+1;
				txt= txt.substring(0, ax)+who.innerHTML+ txt.substring(ax);
			}
			return txt;
		}

		function recipeSelectClick(i){
			if(!recipeTarget)
				return;
			var recipes = recipeTarget.recipes();
			recipeTarget.recipe = recipes[i];
			recipeTarget.cooldown = 0;
			recipeTarget.processing = false;
			var recipeSelector = document.getElementById('recipeSelector');
			recipeSelector.style.display = "none";
		}

		function showRecipeSelect(tile){
			var recipeSelector = document.getElementById('recipeSelector');
			var recipeSelectorContent = document.getElementById('recipeSelectorContent');
			if(recipeSelector.style.display !== "none"){
				recipeSelector.style.display = "none";
				return;
			}
			else if(tile.structure && tile.structure.recipes){
				recipeSelector.style.display = "block";
				recipeTarget = tile.structure;
				var text = "Select a recipe";
				var recipes = tile.structure.recipes();
				for(var i = 0; i < recipes.length; i++)
					text += recipeDraw(recipes[i], "recipeSelectClick(" + i + ")");
				recipeSelectorContent.innerHTML = text;
			}
			else{
				recipeTarget = null;
				recipeSelectorContent.innerHTML = "No recipes available";
			}
		}

		function hideRecipeSelect(){
			var recipeSelector = document.getElementById('recipeSelector');
			recipeSelector.style.display = "none";
		}

		function onKeyDown(event){
			// "R" key rotates the tile
			if(event.keyCode === 82){
				rotate();
			}
			else if(event.keyCode === 37){ // Left arrow
				if(0 < scrollPos[0]){
					scrollPos[0]--;
					updateAllTiles();
				}
			}
			else if(event.keyCode === 38){ // Up arrow
				if(0 < scrollPos[1]){
					scrollPos[1]--;
					updateAllTiles();
				}
			}
			else if(event.keyCode === 39){ // Right arrow
				if(scrollPos[0] + 1 < size - viewPortWidth){
					scrollPos[0]++;
					updateAllTiles();
				}
			}
			else if(event.keyCode === 40){ // Down arrow
				if(scrollPos[1] + 1 < size - viewPortHeight){
					scrollPos[1]++;
					updateAllTiles();
				}
			}
		}

		window.onload = function(){
			window.addEventListener( 'keydown', onKeyDown, false );

			// Set element style to initialize invisible element.
			// CSS value won't be returned by JavaScript property access, so we
			// need to write the initial value from the code.
			var recipeSelector = document.getElementById('recipeSelector');
			recipeSelector.style.display = "none";

			generateBoard();

			// Set animation update function
			window.setInterval(function(){
				run();
			}, 50);
		}

		window.addEventListener('resize', onSize);

		function getTileElem(x, y){
			return tileElems[x + y * viewPortWidth];
		}

		/// Update single tile graphics to match internal data
		function updateTile(tile){
			var idx = board.indexOf(tile);
			var c = idx % size - scrollPos[0];
			var r = Math.floor(idx / size) - scrollPos[1];
			var tileElem = getTileElem(c, r);
			if(!tileElem)
				return;
			tileElem.style.backgroundImage = 'url("img/dirt.png")';
			tileElem.style.transform = '';
			tileElem.style.backgroundColor = 'rgb(' + (255 - tile.ironOre * 255 / 100).toFixed() + ',' +
				(255 - tile.ironOre * 255 / 100 / 2).toFixed() + ',255)';
			// Remove the children first, because old nodes may be present
			while(tileElem.firstChild)
				tileElem.removeChild(tileElem.firstChild);
			if(tile.ironOre){
				var oreElem = document.createElement('div');
				oreElem.style.backgroundImage = 'url("img/iron.png")';
				oreElem.style.backgroundPosition = '-' + Math.floor(tile.ironOre / 25) * 32 + 'px 0';
				oreElem.style.position = 'absolute';
				oreElem.style.width = tilesize + 'px';
				oreElem.style.height = tilesize + 'px';
				tileElem.appendChild(oreElem);
			}

			// The only child of tile element is the tile text.
			if(tile.structure === null)
				/*tileElem.innerHTML = ""*/;
			else{
				tile.structure.draw(tileElem);
			}
		}

		function updateAllTiles(){
			for(var iy = 0; iy < viewPortHeight; iy++){
				for(var ix = 0; ix < viewPortWidth; ix++)
					updateTile(board[(ix + scrollPos[0]) + (iy + scrollPos[1]) * size]);
			}
			for(var i = 0; i < objects.length; i++)
				positionObject(objects[i]);
			updateMiniMapPos();
		}

		function updateMiniMapPos(){
			miniMapCursorElem.style.left = (scrollPos[0] * miniMapSize / size) + 'px';
			miniMapCursorElem.style.top = (scrollPos[1] * miniMapSize / size) + 'px';
		}

		function updateTool(tool){
			if(0 <= tool && tool < toolElems.length){
				// Remove the children first, because old nodes may be present
				while(toolElems[tool].firstChild)
					toolElems[tool].removeChild(toolElems[tool].firstChild);
				toolDefs[tool].prototype.draw.call(toolDefs[tool].prototype, toolElems[tool]);
			}
		}

		function harvest(tile){
			if(tile.structure){
				if(tile.structure.miniMapSymbol){
					miniMapElem.removeChild(tile.structure.miniMapSymbol);
					tile.structure.miniMapSymbol = null;
				}
				if(tile.structure.inventory){
					for(var i in tile.structure.inventory){
						var v = tile.structure.inventory[i];
						if(i in player.inventory)
							player.inventory[i] += v;
						else
							player.inventory[i] = v;
					}
				}
				if(tile.structure.name in player.inventory)
					player.inventory[tile.structure.name]++;
				else
					player.inventory[tile.structure.name] = 1;
				tile.structure = null;
				updatePlayer();
			}
			else{
				var idx = board.indexOf(tile);
				var x = idx % size;
				var y = Math.floor(idx / size);
				findItem(x, y, function(o){
					if(o.type in player.inventory)
						player.inventory[o.type] += 1;
					else
						player.inventory[o.type] = 1;
					updatePlayer();
					return true;
				});
			}
		}

		function createElements(){
			tileElems = new Array(viewPortWidth * viewPortHeight);

			// The containers are nested so that the inner container can be easily
			// discarded to recreate the whole game.
			var outerContainer = document.getElementById("container");
			if(container)
				outerContainer.removeChild(container);
			container = document.createElement("div");
			outerContainer.appendChild(container);
			if(cursorElem)
				cursorElem = null;
			if(toolCursorElem)
				toolCursorElem = null;

			table = document.createElement("div");
			table.style.borderStyle = 'solid';
			table.style.borderWidth = '1px';
			table.style.borderColor = 'red';
			table.style.position = 'relative';
			table.style.left = '50%';
			table.style.width = (viewPortWidth * tilesize) + 'px';
			table.style.height = (viewPortHeight * tilesize) + 'px';

			messageElem = document.createElement('div');
			container.appendChild(messageElem);
			messageElem.style.fontFamily = 'Sans-serif';
			messageElem.style.fontSize = '20pt';
			messageElem.style.position = 'relative';
			messageElem.style.color = 'red';

			container.appendChild(table);
			for(var iy = 0; iy < viewPortHeight; iy++){
				for(var ix = 0; ix < viewPortWidth; ix++){
					var tile = board[ix + iy * size];
					var tileElem = document.createElement("div");
					tileElems[ix + iy * viewPortWidth] = tileElem;
					tileElem.innerHTML = "";
					tileElem.style.width = '32px';
					tileElem.style.height = '32px';
					tileElem.style.position = 'absolute';
					tileElem.style.top = (tilesize * iy) + 'px';
					tileElem.style.left = (tilesize * ix) + 'px';
					tileElem.onmousedown = function(e){
						var idx = tileElems.indexOf(this);
						var c = idx % viewPortWidth + scrollPos[0];
						var r = Math.floor(idx / viewPortWidth) + scrollPos[1];
						var tile = board[c + r * size];

						if(e.button !== 0){
							harvest(tile);
						}
						else if(0 <= currentTool && currentTool < toolDefs.length){
							var tool = toolDefs[currentTool];

							// Prevent resetting structure's progress and inventory if
							// the user clicks on a structure with the same tool type.
							// But update the rotation.
							if(tile.structure && tool.prototype.name === tile.structure.name){
								tile.structure.rotation = currentRotation;
								updateTile(tile);
								return;
							}

							if(!(tool.prototype.name in player.inventory) || !player.inventory[tool.prototype.name])
								return;
							harvest(tile);
							// The tile and the structure built on it should be different
							// object, because it would force us to recreate and replace existing tile object
							// everytime structure is built on it.
							tile.structure = new tool;
							tile.structure.tile = board[c + r * size];
							tile.structure.rotation = currentRotation;
							var symbol = tile.structure.miniMapSymbol = document.createElement('div');
							symbol.style.backgroundColor = '#0000ff';
							symbol.style.width = Math.ceil(miniMapSize / size) + 'px';
							symbol.style.height = Math.ceil(miniMapSize / size) + 'px';
							symbol.style.left = Math.floor(c * miniMapSize / size) + 'px';
							symbol.style.top = Math.floor(r * miniMapSize / size) + 'px';
							symbol.style.position = 'absolute';
							miniMapElem.appendChild(symbol);
							if(--player.inventory[tool.prototype.name] === 0)
								delete player.inventory[tool.prototype.name];
							updatePlayer();
						}
						else{
							// If mouse button is clicked without any tool selected, try to open it (WIP).
							showRecipeSelect(tile);
						}
						updateTile(tile);
						return false;
					}

					// Prevent context menu from right clicking on the tile
					tileElem.oncontextmenu = function(e){
						e.preventDefault();
					}

					tileElem.onmousemove = function(){
						selectTile(this);
					}
					table.appendChild(tileElem);

					// Disable text selection
					tileElem.setAttribute("class", "noselect");

					updateTile(tile);
				}
			}
			// Set the margin after contents are initialized
			table.style.marginLeft = (-table.getBoundingClientRect().width / 2) + 'px';

			var containerRect = container.getBoundingClientRect();
			var tableRect = table.getBoundingClientRect();

			function selectTool(idx){
				// Selecting the same tool twice means deselecting
				if(currentTool === idx)
					idx = -1;
				for(var i = 0; i < toolElems.length; i++)
					toolElems[i].style.backgroundColor = '#ffffff';
				if(0 <= idx && idx < toolElems.length)
					toolElems[idx].style.backgroundColor = '#00ffff';
				currentTool = idx;
				if(0 <= currentTool){
					if(!toolCursorElem){
						toolCursorElem = document.createElement('div');
						toolCursorElem.style.border = '2px blue solid';
						toolCursorElem.style.pointerEvents = 'none';
						toolBarElem.appendChild(toolCursorElem);
					}
					toolCursorElem.style.position = 'absolute';
					toolCursorElem.style.top = '4px';
					toolCursorElem.style.left = (tilesize * currentTool + 4) + 'px';
					toolCursorElem.style.width = '30px';
					toolCursorElem.style.height = '30px';
					toolCursorElem.style.display = 'block';
				}
				else if(toolCursorElem)
					toolCursorElem.style.display = 'none';
			}

			// Reset the state before initializing toolbar elements
			toolElems = [];
			currentTool = -1;
			currentRotation = 0;

			// Tool bar
			toolBarElem = document.createElement('div');
			toolBarElem.style.borderStyle = 'solid';
			toolBarElem.style.borderWidth = '1px';
			toolBarElem.style.borderColor = 'red';
			toolBarElem.style.position = 'relative';
			toolBarElem.margin = '3px';
			toolBarElem.style.left = '50%';
			toolBarElem.style.width = ((toolDefs.length + 1) * tilesize + 8) + 'px';
			toolBarElem.style.height = (tilesize + 8) + 'px';
			container.appendChild(toolBarElem);
			for(var i = 0; i < toolDefs.length; i++){
				var toolElem = document.createElement("div");
				toolElems.push(toolElem);
				toolElem.style.width = '31px';
				toolElem.style.height = '31px';
				toolElem.style.position = 'absolute';
				toolElem.style.top = '4px';
				toolElem.style.left = (32.0 * i + 4) + 'px';
				toolElem.style.border = '1px black solid';
				toolElem.style.textAlign = 'center';
				toolElem.onmousedown = function(e){
					selectTool(toolElems.indexOf(this));
				}
				toolBarElem.appendChild(toolElem);
				// Disable text selection
				toolElem.setAttribute("class", "noselect");
				toolDefs[i].prototype.draw(toolElem);
			}
			var rotateButton = document.createElement('div');
			rotateButton.style.width = '31px';
			rotateButton.style.height = '31px';
			rotateButton.style.position = 'relative';
			rotateButton.style.top = '4px';
			rotateButton.style.left = (32.0 * i + 4) + 'px';
			rotateButton.style.border = '1px blue solid';
			rotateButton.style.backgroundImage = 'url("img/rotate.png")';
			rotateButton.onmousedown = function(e){
				rotate();
			}
			toolBarElem.appendChild(rotateButton);

			// Set the margin after contents are initialized
			toolBarElem.style.marginLeft = (-toolBarElem.getBoundingClientRect().width / 2) + 'px';

			selectTool(-1);

			infoElem = document.createElement('div');
			infoElem.style.position = 'absolute';
			infoElem.style.backgroundColor = '#ffff7f';
			infoElem.style.border = '1px solid #00f';
			container.appendChild(infoElem);

			miniMapElem = document.createElement('div');
			miniMapElem.style.position = 'absolute';
			miniMapElem.style.border = '1px solid #000';
			miniMapElem.onclick = function(evt){
				var rect = this.getBoundingClientRect();
				scrollPos[0] = Math.min(size - viewPortWidth - 1, Math.max(0, Math.floor((evt.clientX - rect.left) / rect.width * size - viewPortWidth / 2.)));
				scrollPos[1] = Math.min(size - viewPortHeight - 1, Math.max(0, Math.floor((evt.clientY - rect.top) / rect.height * size - viewPortHeight / 2.)));
				updateAllTiles();
			};
			container.appendChild(miniMapElem);
			miniMapElem.style.width = miniMapSize + 'px';
			miniMapElem.style.height = miniMapSize + 'px';
			miniMapCursorElem = document.createElement('div');
			miniMapCursorElem.style.backgroundColor = '#ccffff';
			miniMapCursorElem.style.position = 'absolute';
			miniMapCursorElem.style.width = ((viewPortWidth + 1) * miniMapSize / size - 1) + 'px';
			miniMapCursorElem.style.height = ((viewPortHeight + 1) * miniMapSize / size - 1) + 'px';
			miniMapCursorElem.style.border = '1px solid #000';
			miniMapElem.appendChild(miniMapCursorElem);

			playerElem = document.createElement('div');
			playerElem.style.borderStyle = 'solid';
			playerElem.style.borderWidth = '1px';
			playerElem.style.border = '1px solid #00f';
			playerElem.style.backgroundColor = '#ffff7f';
			playerElem.style.position = 'relative';
			playerElem.style.margin = '3px';
			playerElem.style.left = '50%';
			playerElem.style.width = (320) + 'px';
			playerElem.style.height = (160) + 'px';
			container.appendChild(playerElem);
			playerElem.style.marginLeft = (-playerElem.getBoundingClientRect().width / 2) + 'px';

			onSize();

			debugText = document.createElement('div');
			container.appendChild(debugText);
		}

		function onSize(){
			var tableRect = table.getBoundingClientRect();

			miniMapElem.style.left = (tableRect.right + 20) + 'px';
			miniMapElem.style.top = '0px';
			miniMapElem.style.left = (tableRect.right + 20) + 'px';
			var mrect = miniMapElem.getBoundingClientRect();
			updateMiniMapPos();

			var rect = infoElem.getBoundingClientRect();
			infoElem.style.left = (tableRect.right + 20) + 'px';
			infoElem.style.top = (mrect.height + 20) + 'px';
			infoElem.style.width = '150px';
			infoElem.style.height = (tableRect.height - mrect.height - 20) + 'px';
			infoElem.style.textAlign = 'left';
		}

		function updateInfo(){
			if(!selectedCoords){
				infoElem.innerHTML = 'Empty tile';
				return;
			}
			var tile = board[selectedCoords[0] + selectedCoords[1] * size];
			if(!tile || !tile.structure){
				infoElem.innerHTML = 'Empty tile<br>' +
					'Iron Ore: ' + tile.ironOre;
				return;
			}
			infoElem.innerHTML = 'Type: ' + tile.structure.name + '<br>' +
				(tile.structure.desc ? tile.structure.desc(tile) : "");
		}

		function generateItemImage(i, iconSize, count){
			var img = document.createElement('img');
			if(i === 'time')
				img.src = 'img/time.png';
			else if(i === 'O')
				img.src = 'img/ore.png';
			else if(i === 'M')
				img.src = 'img/metal.png';
			else if(i === 'Gear')
				img.src = 'img/gear.png';
			else if(i === 'Transport Belt')
				img.src = 'img/transport.png';
			else if(i === 'Inserter')
				img.src = 'img/inserter-base.png';
			else if(i === 'Chest')
				img.src = 'img/chest.png';
			else if(i === 'Ore Mine')
				img.src = "img/mine.png";
			else if(i === 'Furnace')
				img.src = "img/furnace.png";
			else if(i === 'Assembler')
				img.src = "img/assembler.png";
			var size = iconSize ? 32 : objViewSize;
			img.style.width = size + 'px';
			img.style.height = size + 'px';
			if(iconSize && count){
				var container = document.createElement('span');
				container.style.position = 'relative';
				container.appendChild(img);
				var overlay = document.createElement('div');
				overlay.setAttribute('class', 'overlay');
				overlay.innerHTML = count;
				container.appendChild(overlay);
				return container;
			}
			return img;
		}

		function updatePlayer(){
			// Clear the elements first
			while(playerElem.firstChild)
				playerElem.removeChild(playerElem.firstChild);

			for(var i in player.inventory){
				var v = player.inventory[i];
				var div = document.createElement('div');
				div.appendChild(generateItemImage(i));
				var text = document.createElement('span');
				text.innerHTML = v + ' ' + i;
				div.appendChild(text);
				div.style.textAlign = 'left';
				if(player.selectedInventory === i)
					div.style.backgroundColor = '#00ffff';
				div.setAttribute('class', 'noselect');
				div.itemName = i;
				div.onclick = function(){
					if(player.selectedInventory !== this.itemName)
						player.selectedInventory = this.itemName;
					else
						player.selectedInventory = null;
					updatePlayer();
				};
				playerElem.appendChild(div);
			}
		}

		function selectTile(sel){
			selectedTile = sel;
			var idx = tileElems.indexOf(sel);
			var vx = idx % viewPortWidth;
			var vy = Math.floor(idx / viewPortWidth);
			var ix = vx + scrollPos[0];
			var iy = vy + scrollPos[1];
			selectedCoords = [ix, iy];
			if(ix < size && iy < size){
				if(!cursorElem){
					cursorElem = document.createElement('div');
					cursorElem.style.border = '2px blue solid';
					cursorElem.style.pointerEvents = 'none';
					table.appendChild(cursorElem);
				}
				cursorElem.style.position = 'absolute';
				cursorElem.style.top = (tilesize * vy) + 'px';
				cursorElem.style.left = (tilesize * vx) + 'px';
				cursorElem.style.width = '30px';
				cursorElem.style.height = '30px';
				updateInfo();
			}
		}

		function generateBoard(){
			var sizeStr = document.getElementById("sizeSelect").value;
			size = parseInt(sizeStr);
			viewPortWidth = 16;
			viewPortHeight = 12;
			board = new Array(size * size);

			for(var i = 0; i < size * size; i++)
				board[i] = newblock();

			scrollPos = [0, 0];

			createElements();

			// Initial inventory of player
			player.inventory['O'] = 50;
			player.inventory['M'] = 10;
			player.inventory['Transport Belt'] = 20;
			player.inventory['Inserter'] = 10;
			player.inventory['Chest'] = 10;
			player.inventory['Ore Mine'] = 5;
			player.inventory['Furnace'] = 3;
			player.inventory['Assembler'] = 3;
			updatePlayer();
		}

		function newblock(){
			return {
				structure: null,
				ironOre: Math.max(0, (Math.random() * 200 - 100).toFixed()),
			};
		}

		var serialNo = 0;

		/// Check whether given tile allow objects on it, e.g. transport belts
		function movableTile(x, y){
			var tx = Math.floor(x / tilesize);
			var ty = Math.floor(y / tilesize);
			if(tx < 0 || size < tx || ty < 0 || size < ty || isNaN(tx) || isNaN(ty))
				return false;
			// Ojects should not be placed on an empty tile
			if(!board[tx + ty * size].structure)
				return false;
			return board[tx + ty * size].structure.movable();
		}

		/// Check whether given coordinates hits some object
		function hitCheck(x, y, ignore){
			for(var j = 0; j < objects.length; j++){
				var jo = objects[j];
				if(ignore === jo)
					continue;
				if(Math.abs(x - jo.x) < objsize && Math.abs(y - jo.y) < objsize)
					return true;
			}
			return false;
		}

		/// Insert an object on the board.  It could fail if there's already some object at the position.
		function newObject(c, r, type){
			var obj = {id: serialNo++, type: type, x: c * tilesize + tilesize / 2, y: r * tilesize + tilesize / 2};
			if(0 <= c && c < size && 0 <= r && r < size && board[c + r * size].structure && !board[c + r * size].structure.movable()){
				return board[c + r * size].structure.input(obj);
			}
			if(hitCheck(obj.x, obj.y))
				return false;
			obj.elem = document.createElement('div');
			if(type === 'O')
				obj.elem.style.backgroundImage = 'url("img/ore.png")';
			else if(type === 'M')
				obj.elem.style.backgroundImage = 'url("img/metal.png")';
			else if(type === 'Gear')
				obj.elem.style.backgroundImage = 'url("img/gear.png")';
			else if(type === 'Transport Belt')
				obj.elem.style.backgroundImage = 'url("img/transport.png")';
			else if(type === 'Inserter')
				obj.elem.style.backgroundImage = 'url("img/inserter-base.png")';
			else if(type === 'Chest')
				obj.elem.style.backgroundImage = 'url("img/chest.png")';
			else if(type === 'Ore Mine')
				obj.elem.style.backgroundImage = 'url("img/mine.png")';
			else
				obj.elem.innerHTML = type;
			obj.elem.style.backgroundSize = objViewSize + 'px ' + objViewSize + 'px';
			// Debug graphic for bounding box
//			obj.elem.style.border = '1px solid';
			obj.elem.style.width = objViewSize + 'px';
			obj.elem.style.height = objViewSize + 'px';
			obj.elem.style.position = 'absolute';
			// Disable mouse events since we don't want an object to catch mouse event when
			// we're adding a structure to a tile.
			obj.elem.style.pointerEvents = 'none';
			obj.elem.setAttribute('class', 'noselect');
			positionObject(obj);
			table.appendChild(obj.elem);
			objects.push(obj);
			return true;
		}

		function positionObject(obj){
			var vx = obj.x - scrollPos[0] * tilesize;
			var vy = obj.y - scrollPos[1] * tilesize;
			if(vx < 0 || viewPortWidth * tilesize < vx || vy < 0 || viewPortHeight * tilesize < vy){
				obj.elem.style.display = 'none';
				return;
			}
			obj.elem.style.display = 'block';
			obj.elem.style.left = (vx - objViewSize / 2) + 'px';
			obj.elem.style.top = (vy - objViewSize / 2) + 'px';
		}

		var simstep = 0;

		/// Simulation step function
		function run(){
			// Iterate all floating objects to update
			for(var i = 0; i < objects.length; i++){
				var o = objects[i];

				// Obtain coordinates and tile at the position
				var tx = Math.floor(o.x / tilesize);
				var ty = Math.floor(o.y / tilesize);
				var tile = board[tx + ty * size];
				if(tile.structure)
					tile.structure.objectResponse(tile, o);
			}

			for(var ty = 0; ty < size; ty++){
				for(var tx = 0; tx < size; tx++){
					var tile = board[tx + ty * size];
					if(tile.structure)
						tile.structure.frameProc(tile);
				}
			}

			updateInfo();

			simstep++;
		}

		</script>

	</body>
</html>
